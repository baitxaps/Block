一、关键字
迎合swift,提高开发规范，减少程序员之间的交流
1.
@property(nonatomic,strong,nullable)NSString *name;
@property(nonatomic,strong)NSString * _Nullable name;
@property(nonatomic,strong)NSString * __nullable name;

@property(nonatomic,nonnull,strong)NSString * name;
@property(nonatomic,strong)NSString * _Nonnull name;
@property(nonatomic,strong)NSString *__nonnull name;

- (nonnull NSString *)test:(nonnull NSString*)str;
- (NSString *_Nonnull)test1:(NSString *_Nullnull)str;
2.
NS_ASSUME_NONNULL_BEGIN 和NS_ASSUME_NUNNULL_END
之间定义的所有属性默认都包含nonnull功能

3.null_resettable
@property(nonatomic,strong,null_resettable)NSString *name
set方法可为空，get方法不能为空, 注意如果使用null_resettable，必须重写get 或set方法，处理传递的值为空的情况

4._Null_unsepcified ：不确定是否为空
 因为3中,不确定是调用get 或set 方法，书写方式只有下面这两种：
@property(nonatomic,strong)NSString *_Null_unsepcified name;这样写没有什么意义
@property(nonatomic,strong)NSString *__null_unsepcified name

二、泛型
使用场景：集合是使用比较常见，只能修饰方法的调用
好处：
提高开发规范，减少程序员之间交流
通过集合取出来对象，直接当做泛型对象使用，可以直接使用点语法

书定规范:NSMutableArray<NSString*>*datas;
@prooert(nonatomic,strong)NSMutableArray<NSString*>*datas;
// self.datas[1].length

// 声明
@interface Person<ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

@interface Job:NSObject @end
@implement Person @end

// 定义
{
Person<Job *>tmp = [Job new];
Person<NSString *>sting = @"string;
}

三、协变、逆变
1.__covariant:用于泛型数据强转，可以向上强转，子类可以转成父类
@interface Person<__covariant ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

@interface Info :Person @end
@implement Person @end

{
 Person <Job*>*p = [Person new];
 Info <Sex*>*I = [Inof new];
  p = i;
}

2.逆变 __contravariant 用于泛型数据强转，可以向下强转，父类可以转成子类
@interface Person<__contravariant ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

四、__kindof
当前类或它的子类, 在调用的时候，很清楚的知道返回类型
书写格式：放在类型前面
+ (__kindof instancetype)Person;

五、id与instancetype
id 坏处：
1>不能在编译的时候检查真实类型 
2>  返回值，没有提示
instancetype:
会自动识别当前的对象类

//END

============================================================================================
//runtime
============================================================================================
六、runtime
是一套底层的纯C API,属于C的一个库，里面包含了很多底层C的API
平时编写的OC代码，在程序运行过程中，最终都转成了runtime的C代码，runtime算是Ｃ的幕后工作者
runtime属于OC底层，可以进行一些非常底层的操作（OC是不好实现的）：
在程序动行中动态创建一个类，如KVC，KVO底层的实现
在程度中动态为某个类添加属性和方法，悠改属性值和方法
遍历所有属性和方法(字典转模型，归档是用循环实现)

1.消息发送
build ->msg ->NO
实例方法
- (void)run:(int)a;
objc_msgSend(p,@selector(run:),10);

类方法：本质类名转换成类对象
Class person = [Person class];
person performSelector:@selector:(done)];

[objc_msgSend(person,@selector(done)];

2.方法交换
class_getMethodImplementation:获取方法实现
class_getInstanceMethod:获取对象
class_getClassMehtod:获取类方法

+(void)load {
	method imageNameMethod = class_getClassMehtod([UIImage class],@selector(imagedNamed:));
	method rhc_imageNameMethod =  class_getClassMehtod([UIImage class],@selector(rhc_imagedNamed:));
	method_exchangeImplementations(imageNameMethod,rhc_imageNameMethod);
}

+ (UIImage*)rhc_imagedNamed:(NSString*)imaged {
	UIImage *tmp = [UIImage rhc_imagedName:imaged];
	if(!tmp){
	 
	}
	return tmp;
  }
}

{
 UIImage = [UIImage imaged:@"rhc"];
}

3.动态的添加方法
没有参数
[obj performSelector:@selector(done)];动态添加方法
首先实现resolveInstanceMethod
+(BOOL)resolveInstanceMethod:(SEL)sel {
	if([sel==@selector(done)]){
		class_addMethod(self,sel,(IMP)rhc,"v@:");
		return YES;
	}
	
	return [super resolveInstanceMethod:sel];
}
class_addMethod：
cls :给哪个类型添加方法
SEL:添加方法的方法编号是什么
IMP:方法实现，函数入口，函数名
types:方法类型

v@:返回值v->void,@->id（id 对象）,:->sel（方法纺号）

// 默认一个方法都有两个参数：self,_cmd,隐式参数,不用传
self 方法调用者
_cmd:调用方法的编号
void rhc(id self,SEL _cmd){}

一个参数
[obj performSelector:@selector(run:) withObject:@"rhc"];动态添加方法

class_addMethod(self,sel,(IMP)test,"v@:@");

void test(id self,SEL _cmd,id param1){}

4.给分类添加属性

@interface NSObject(Objc）
@property(nonatomic,strong)NSString *name;
@end

@implement NSObject(Objc)

- (void)setName:(NSString*)name {
  //objc_setAssociatedObject(self,const id key,id valeu,objc_AssociationPolicy pllicy)
  objc_setAssociatedObject(self,@"name",name,OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSString *)name {
	return objc_getAssociatedObject(self,@"name");
}
@end

5.字典转模型KVC：遍历字典中所有key,去模型中查找有没有对应的属性名

字典转模型runtime:遍历模型中所有属性，去字典中查找
class_copyIvarList:把成员属性列表复制一份给你
Ivar *:指向一个成员变量数组
Ivar *ivarList = class_copyIvarList(self, &count);

KVO底层实现原理:
研究KVO的时候我们发现系统使用Objective-C 强大的runtime功能实现了这个功能。
属性类class中并没有实现KVO通知的相关方案，而是在调用addObserver之后定义属性类的子类subclass，
subclass里边实现了属性的setter方法，setter方法中实现发动通知的功能。然后subclass中实现class函数，
还让返回属性类的class，再让属性类对象的isa指向subclass，这样就伪装成表面上看还是属性类自己实现的通知功能。
通过原理我们可以看出， 必须使用属性方法或者setValue:forKey方法赋值才会发送通知，直接赋值是不会收到通知的


6.线程和进行
每个在系统上运行的程序都是一个进程
每个进程包含一到多个线程
线程是一组指令的集合，或者是程序的特殊段，他可以在程序里独立执行
//END

7.KVC
使用观察者模式需要被观察者的配合，当被观察者的状态发生变化的时候通过事先定义好的接口（协议）通知观察者。
在KVO的使用中我们并不需要向被观察者添加额外的代码，就能在被观察的属性变化的时候得到通知，这个功能是如何实现的呢？
同KVC一样依赖于强大的Runtime机制。
系统实现KVO有以下几个步骤：
当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。
在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。
类B重写会 class方法，将自己伪装成类A。
类B还会重写dealloc方法释放资源。
系统将所有指向类A对象的isa指针指向类B的对象。
KVO同KVC一样，通过 isa-swizzling 技术来实现。
当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。
其结果是，isa指针的值并不一定反映实例的实际类。
所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类

KVC
KVC和KVO都属于键值编程而且底层实现机制都是isa-swizzing
KVC概述 KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。
而不是通过调用Setter、Getter方法访问。 关键方法定义在 NSKeyValueCodingProtocol KVC支持类对象和内建基本数据类型。
KVC使用 获取值 valueForKey: 传入NSString属性的名字。
valueForKeyPath: 属性的路径，xx.xx valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理
修改值 setValue:forKey: setValue:forKeyPath:
setValue:forUnderfinedKey: setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。
KVC键值查找 搜索单值成员 setValue:forKey:搜索方式

1、首先搜索setKey:方法。（key指成员变量名，首字母大写）
2、上面的setter方法没找到，如果类方法accessInstanceVariablesDirectly返回YES。
   那么按 _key，_isKey，key，iskey的顺序搜索成员名。
（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES）
3、如果没有找到成员变量，调用setValue:forUnderfinedKey:

valueForKey:的搜索方式
1、首先按getKey，key，isKey的顺序查找getter方法，找到直接调用。如果是BOOL、int等内建值类型，会做NSNumber的转换。
2、上面的getter没找到，查找countOfKey、objectInKeyAtindex、KeyAtindexes格式的方法。
如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。
3、还没找到，查找countOfKey、enumeratorOfKey、memberOfKey格式的方法。如果这三个方法都找到，
那么就返回一个可以响应NSSet所有方法的代理集合。
4、还是没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。
5、再没找到，调用valueForUndefinedKey。

KVC实现分析 KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。
KVC通过isa-swizzing实现其内部查找定位。isa指针（is kind of 的意思）指向维护分发表的对象的类，
该分发表实际上包含了指向实现类中的方法的指针和其他数据。

比如说如下的一行KVC代码：
[site setValue:@"sitename" forKey:@"name"];
//会被编译器处理成
SEL sel = sel_get_uid(setValue:forKey);
IMP method = objc_msg_loopup(site->isa,sel);
method(site,sel,@"sitename",@"name");
每个类都有一张方法表，是一个hash表，值是还书指针IMP，
SEL的名称就是查表时所用的键。 SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。
IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，
就会指向一个IMP对象，这个对象是C语言表述的类型。

KVC的内部机制： 一个对象在调用setValue的时候进行了如下操作：
(1）根据方法名找到运行方法的时候需要的环境参数
(2）他会从自己的isa指针结合环境参数，找到具体的方法实现接口。
(3)再直接查找得来的具体的实现方法

一.isa指针
要认识什么是isa指针，我们得先明确一点：
在Objective-C中，任何类的定义都是对象。
类和类的实例（对象）没有任何本质上的区别。任何对象都有isa指针。
那么什么是类呢？
在xcode中用快捷键Shift＋Cmd＋O 打开文件objc.h 能看到类的定义：
可以看出:
Class 是一个 objc_class 结构类型的指针, id是一个 objc_object 结构类型的指针.
我们再来看看 objc_class 的定义：
稍微解释一下各个参数的意思：
isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。
元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。
同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).
根元类的isa指针指向本身，这样形成了一个封闭的内循环。

super_class：父类，如果该类已经是最顶层的根类,那么它为NULL。
version：类的版本信息,默认为0
info：供运行期使用的一些位标识。
instance_size：该类的实例变量大小
ivars：成员变量的数组
再来看看各个类实例变量的继承关系：
每一个对象本质上都是一个类的实例。其中类定义了成员变量和成员方法的列表。对象通过对象的isa指针指向类。
每一个类本质上都是一个对象，类其实是元类（meteClass）的实例。元类定义了类方法的列表。类通过类的isa指针指向元类。
所有的元类最终继承一个根元类，根元类isa指针指向本身，形成一个封闭的内循环。

二.runtime 机制
runtime：指一个程序在运行（或者在被执行）的状态。也就是说，当你打开一个程序使它在电脑上运行的时候，那个程序就是处于运行时刻。
在一些编程语言中，把某些可以重用的程序或者实例打包或者重建成为“运行库"。这些实例可以在它们运行的时候被连接或者被任何程序调用。

objective-c中runtime：是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。
在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码。

runtime的应用：
1.动态创建一个类(比如KVO的底层实现)
2.动态地为某个类添加属性\方法, 修改属性值\方法
3.遍历一个类的所有成员变量(属性)\所有方法
实质上，以上的是通过相关方法来获取对象或者类的isa指针来实现的。
相关函数
1.增加
增加函数:class_addMethod
增加实例变量:class_addIvar
增加属性:@dynamic标签，或者class_addMethod，因为属性其实就是由getter和setter函数组成
增加Protocol:class_addProtocol (说实话我真不知道动态增加一个protocol有什么用,-_-!!)

2.获取
获取函数列表及每个函数的信息(函数指针、函数名等等):class_getClassMethod method_getName ...
获取属性列表及每个属性的信息:class_copyPropertyList property_getName
获取类本身的信息,如类名等：class_getName class_getInstanceSize
获取变量列表及变量信息：class_copyIvarList
获取变量的值

3.替换

将实例替换成另一个类：object_setClass
替换类方法的定义：class_replaceMethod

4.其他常用方法：
交换两个方法的实现：method_exchangeImplementations.
设置一个方法的实现：method_setImplementation.
http://www.jianshu.com/p/41735c66dccb
