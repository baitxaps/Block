一、关键字
迎合swift,提高开发规范，减少程序员之间的交流
1.
@property(nonatomic,strong,nullable)NSString *name;
@property(nonatomic,strong)NSString * _Nullable name;
@property(nonatomic,strong)NSString * __nullable name;

@property(nonatomic,nonnull,strong)NSString * name;
@property(nonatomic,strong)NSString * _Nonnull name;
@property(nonatomic,strong)NSString *__nonnull name;

- (nonnull NSString *)test:(nonnull NSString*)str;
- (NSString *_Nonnull)test1:(NSString *_Nullnull)str;
2.
NS_ASSUME_NONNULL_BEGIN 和NS_ASSUME_NUNNULL_END
之间定义的所有属性默认都包含nonnull功能

3.null_resettable
@property(nonatomic,strong,null_resettable)NSString *name
set方法可为空，get方法不能为空, 注意如果使用null_resettable，必须重写get 或set方法，处理传递的值为空的情况

4._Null_unsepcified ：不确定是否为空
 因为3中,不确定是调用get 或set 方法，书写方式只有下面这两种：
@property(nonatomic,strong)NSString *_Null_unsepcified name;这样写没有什么意义
@property(nonatomic,strong)NSString *__null_unsepcified name

二、泛型
使用场景：集合是使用比较常见，只能修饰方法的调用
好处：
提高开发规范，减少程序员之间交流
通过集合取出来对象，直接当做泛型对象使用，可以直接使用点语法

书定规范:NSMutableArray<NSString*>*datas;
@prooert(nonatomic,strong)NSMutableArray<NSString*>*datas;
// self.datas[1].length

// 声明
@interface Person<ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

@interface Job:NSObject @end
@implement Person @end

// 定义
{
Person<Job *>tmp = [Job new];
Person<NSString *>sting = @"string;
}

三、协变、逆变
1.__covariant:用于泛型数据强转，可以向上强转，子类可以转成父类
@interface Person<__covariant ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

@interface Info :Person @end
@implement Person @end

{
 Person <Job*>*p = [Person new];
 Info <Sex*>*I = [Inof new];
  p = i;
}

2.逆变 __contravariant 用于泛型数据强转，可以向下强转，父类可以转成子类
@interface Person<__contravariant ObjectType>:NSObject @end
@property(nonatomic,strong)ObjectType tree;
@implement Person @end

四、__kindof
当前类或它的子类, 在调用的时候，很清楚的知道返回类型
书写格式：放在类型前面
+ (__kindof instancetype)Person;

五、id与instancetype
id 坏处：
1>不能在编译的时候检查真实类型 
2>  返回值，没有提示
instancetype:
会自动识别当前的对象类

//END

============================================================================================
//runtime
============================================================================================
六、runtime
是一套底层的纯C API,属于C的一个库，里面包含了很多底层C的API
平时编写的OC代码，在程序运行过程中，最终都转成了runtime的C代码，runtime算是Ｃ的幕后工作者
runtime属于OC底层，可以进行一些非常底层的操作（OC是不好实现的）：
在程序动行中动态创建一个类，如KVC，KVO底层的实现
在程度中动态为某个类添加属性和方法，悠改属性值和方法
遍历所有属性和方法(字典转模型，归档是用循环实现)

1.消息发送
build ->msg ->NO
实例方法
- (void)run:(int)a;
objc_msgSend(p,@selector(run:),10);

类方法：本质类名转换成类对象
Class person = [Person class];
person performSelector:@selector:(done)];

[objc_msgSend(person,@selector(done)];

2.方法交换
class_getMethodImplementation:获取方法实现
class_getInstanceMethod:获取对象
class_getClassMehtod:获取类方法

+(void)load {
	method imageNameMethod = class_getClassMehtod([UIImage class],@selector(imagedNamed:));
	method rhc_imageNameMethod =  class_getClassMehtod([UIImage class],@selector(rhc_imagedNamed:));
	method_exchangeImplementations(imageNameMethod,rhc_imageNameMethod);
}

+ (UIImage*)rhc_imagedNamed:(NSString*)imaged {
	UIImage *tmp = [UIImage rhc_imagedName:imaged];
	if(!tmp){
	 
	}
	return tmp;
  }
}

{
 UIImage = [UIImage imaged:@"rhc"];
}

3.动态的添加方法
没有参数
[obj performSelector:@selector(done)];动态添加方法
首先实现resolveInstanceMethod
+(BOOL)resolveInstanceMethod:(SEL)sel {
	if([sel==@selector(done)]){
		class_addMethod(self,sel,(IMP)rhc,"v@:");
		return YES;
	}
	
	return [super resolveInstanceMethod:sel];
}
class_addMethod：
cls :给哪个类型添加方法
SEL:添加方法的方法编号是什么
IMP:方法实现，函数入口，函数名
types:方法类型

v@:返回值v->void,@->id（id 对象）,:->sel（方法纺号）

// 默认一个方法都有两个参数：self,_cmd,隐式参数,不用传
self 方法调用者
_cmd:调用方法的编号
void rhc(id self,SEL _cmd){}

一个参数
[obj performSelector:@selector(run:) withObject:@"rhc"];动态添加方法

class_addMethod(self,sel,(IMP)test,"v@:@");

void test(id self,SEL _cmd,id param1){}

4.给分类添加属性

@interface NSObject(Objc）
@property(nonatomic,strong)NSString *name;
@end

@implement NSObject(Objc)

- (void)setName:(NSString*)name {
  //objc_setAssociatedObject(self,const id key,id valeu,objc_AssociationPolicy pllicy)
  objc_setAssociatedObject(self,@"name",name,OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}

- (NSString *)name {
	return objc_getAssociatedObject(self,@"name");
}
@end

5.字典转模型KVC：遍历字典中所有key,去模型中查找有没有对应的属性名

字典转模型runtime:遍历模型中所有属性，去字典中查找
class_copyIvarList:把成员属性列表复制一份给你
Ivar *:指向一个成员变量数组
Ivar *ivarList = class_copyIvarList(self, &count);


6.线程和进行
每个在系统上运行的程序都是一个进程
每个进程包含一到多个线程
线程是一组指令的集合，或者是程序的特殊段，他可以在程序里独立执行
//END

7.kvo
使用观察者模式需要被观察者的配合，当被观察者的状态发生变化的时候通过事先定义好的接口（协议）通知观察者。在KVO的使用中我们并不需要向被观察者添加额外的代码，就能在被观察的属性变化的时候得到通知，这个功能是如何实现的呢？同KVC一样依赖于强大的Runtime机制。
系统实现KVO有以下几个步骤：
当类A的对象第一次被观察的时候，系统会在运行期动态创建类A的派生类。我们称为B。
在派生类B中重写类A的setter方法，B类在被重写的setter方法中实现通知机制。
类B重写会 class方法，将自己伪装成类A。类B还会重写dealloc方法释放资源。
系统将所有指向类A对象的isa指针指向类B的对象。
KVO同KVC一样，通过 isa-swizzling 技术来实现。当观察者被注册为一个对象的属性的观察对象的isa指针被修改，指向一个中间类，而不是在真实的类。其结果是，isa指针的值并不一定反映实例的实际类。
所以不能依靠isa指针来确定对象是否是一个类的成员。应该使用class方法来确定对象实例的类

kvc
KVC和KVO都属于键值编程而且底层实现机制都是isa-swizzing，所以本来想放在一起讲的。但是篇幅有限所以就分成了两篇博文 KVO实现机制传送门

KVC概述 KVC是Key Value Coding的简称。它是一种可以通过字符串的名字（key）来访问类属性的机制。而不是通过调用Setter、Getter方法访问。 关键方法定义在 NSKeyValueCodingProtocol KVC支持类对象和内建基本数据类型。 KVC使用 获取值 valueForKey: 传入NSString属性的名字。 valueForKeyPath: 属性的路径，xx.xx valueForUndefinedKey 默认实现是抛出异常，可重写这个函数做错误处理

修改值 setValue:forKey: setValue:forKeyPath: setValue:forUnderfinedKey: setNilValueForKey: 对非类对象属性设置nil时调用，默认抛出异常。

KVC键值查找 搜索单值成员 setValue:forKey:搜索方式

1、首先搜索setKey:方法。（key指成员变量名，首字母大写）

2、上面的setter方法没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。（NSKeyValueCodingCatogery中实现的类方法，默认实现为返回YES）

3、如果没有找到成员变量，调用setValue:forUnderfinedKey:

valueForKey:的搜索方式

1、首先按getKey，key，isKey的顺序查找getter方法，找到直接调用。如果是BOOL、int等内建值类型，会做NSNumber的转换。

2、上面的getter没找到，查找countOfKey、objectInKeyAtindex、KeyAtindexes格式的方法。如果countOfKey和另外两个方法中的一个找到，那么就会返回一个可以响应NSArray所有方法的代理集合的NSArray消息方法。

3、还没找到，查找countOfKey、enumeratorOfKey、memberOfKey格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所有方法的代理集合。 4、还是没找到，如果类方法accessInstanceVariablesDirectly返回YES。那么按 _key，_isKey，key，iskey的顺序搜索成员名。

5、再没找到，调用valueForUndefinedKey。

KVC实现分析 KVC运用了isa-swizzing技术。isa-swizzing就是类型混合指针机制。KVC通过isa-swizzing实现其内部查找定位。isa指针（is kind of 的意思）指向维护分发表的对象的类，该分发表实际上包含了指向实现类中的方法的指针和其他数据。

比如说如下的一行KVC代码：

[site setValue:@"sitename" forKey:@"name"];

//会被编译器处理成

SEL sel = sel_get_uid(setValue:forKey); IMP method = objc_msg_loopup(site->isa,sel); method(site,sel,@"sitename",@"name"); 每个类都有一张方法表，是一个hash表，值是还书指针IMP，SEL的名称就是查表时所用的键。 SEL数据类型：查找方法表时所用的键。定义成char*，实质上可以理解成int值。 IMP数据类型：他其实就是一个编译器内部实现时候的函数指针。当Objective-C编译器去处理实现一个方法的时候，就会指向一个IMP对象，这个对象是C语言表述的类型。

KVC的内部机制： 一个对象在调用setValue的时候进行了如下操作：

（1）根据方法名找到运行方法的时候需要的环境参数 （2）他会从自己的isa指针结合环境参数，找到具体的方法实现接口。 （3）再直接查找得来的具体的实现方法
